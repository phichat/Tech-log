/**
 * @fileoverview Rule to require parens in arrow function arguments.
 * @author Jxck
 */
"use strict";

//------------------------------------------------------------------------------
<<<<<<< HEAD
=======
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("../ast-utils");

//------------------------------------------------------------------------------
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        docs: {
            description: "require parentheses around arrow function arguments",
            category: "ECMAScript 6",
            recommended: false
        },

        fixable: "code",

        schema: [
            {
                enum: ["always", "as-needed"]
            },
            {
                type: "object",
                properties: {
                    requireForBlockBody: {
                        type: "boolean"
                    }
                },
                additionalProperties: false
            }
        ]
    },

    create(context) {
        const message = "Expected parentheses around arrow function argument.";
        const asNeededMessage = "Unexpected parentheses around single function argument.";
        const asNeeded = context.options[0] === "as-needed";
        const requireForBlockBodyMessage = "Unexpected parentheses around single function argument having a body with no curly braces";
        const requireForBlockBodyNoParensMessage = "Expected parentheses around arrow function argument having a body with curly braces.";
        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;

        const sourceCode = context.getSourceCode();

<<<<<<< HEAD

=======
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
        /**
         * Determines whether a arrow function argument end with `)`
         * @param {ASTNode} node The arrow function node.
         * @returns {void}
         */
        function parens(node) {
<<<<<<< HEAD
            const token = sourceCode.getFirstToken(node, node.async ? 1 : 0);
=======
            const isAsync = node.async;
            const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);

            /**
             * Remove the parenthesis around a parameter
             * @param {Fixer} fixer Fixer
             * @returns {string} fixed parameter
             */
            function fixParamsWithParenthesis(fixer) {
                const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);
                const closingParenToken = sourceCode.getTokenAfter(paramToken);
                const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;
                const shouldAddSpaceForAsync = asyncToken && (asyncToken.end === firstTokenOfParam.start);

                return fixer.replaceTextRange([
                    firstTokenOfParam.range[0],
                    closingParenToken.range[1]
                ], `${shouldAddSpaceForAsync ? " " : ""}${paramToken.value}`);
            }
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2

            // "as-needed", { "requireForBlockBody": true }: x => x
            if (
                requireForBlockBody &&
                node.params.length === 1 &&
                node.params[0].type === "Identifier" &&
                !node.params[0].typeAnnotation &&
                node.body.type !== "BlockStatement" &&
                !node.returnType
            ) {
<<<<<<< HEAD
                if (token.type === "Punctuator" && token.value === "(") {
                    context.report({
                        node,
                        message: requireForBlockBodyMessage,
                        fix(fixer) {
                            const paramToken = context.getTokenAfter(token);
                            const closingParenToken = context.getTokenAfter(paramToken);

                            return fixer.replaceTextRange([
                                token.range[0],
                                closingParenToken.range[1]
                            ], paramToken.value);
                        }
=======
                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
                    context.report({
                        node,
                        message: requireForBlockBodyMessage,
                        fix: fixParamsWithParenthesis
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
                    });
                }
                return;
            }

            if (
                requireForBlockBody &&
                node.body.type === "BlockStatement"
            ) {
<<<<<<< HEAD
                if (token.type !== "Punctuator" || token.value !== "(") {
=======
                if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
                    context.report({
                        node,
                        message: requireForBlockBodyNoParensMessage,
                        fix(fixer) {
<<<<<<< HEAD
                            return fixer.replaceText(token, `(${token.value})`);
=======
                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
                        }
                    });
                }
                return;
            }

            // "as-needed": x => x
            if (asNeeded &&
                node.params.length === 1 &&
                node.params[0].type === "Identifier" &&
                !node.params[0].typeAnnotation &&
                !node.returnType
            ) {
<<<<<<< HEAD
                if (token.type === "Punctuator" && token.value === "(") {
                    context.report({
                        node,
                        message: asNeededMessage,
                        fix(fixer) {
                            const paramToken = context.getTokenAfter(token);
                            const closingParenToken = context.getTokenAfter(paramToken);

                            return fixer.replaceTextRange([
                                token.range[0],
                                closingParenToken.range[1]
                            ], paramToken.value);
                        }
=======
                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
                    context.report({
                        node,
                        message: asNeededMessage,
                        fix: fixParamsWithParenthesis
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
                    });
                }
                return;
            }

<<<<<<< HEAD
            if (token.type === "Identifier") {
                const after = sourceCode.getTokenAfter(token);
=======
            if (firstTokenOfParam.type === "Identifier") {
                const after = sourceCode.getTokenAfter(firstTokenOfParam);
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2

                // (x) => x
                if (after.value !== ")") {
                    context.report({
                        node,
                        message,
                        fix(fixer) {
<<<<<<< HEAD
                            return fixer.replaceText(token, `(${token.value})`);
=======
                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
                        }
                    });
                }
            }
        }

        return {
            ArrowFunctionExpression: parens
        };
    }
};
