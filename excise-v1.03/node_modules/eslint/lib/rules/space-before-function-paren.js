/**
 * @fileoverview Rule to validate spacing before function paren.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("../ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        docs: {
            description: "enforce consistent spacing before `function` definition opening parenthesis",
            category: "Stylistic Issues",
            recommended: false
        },

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    {
                        enum: ["always", "never"]
                    },
                    {
                        type: "object",
                        properties: {
                            anonymous: {
                                enum: ["always", "never", "ignore"]
                            },
                            named: {
                                enum: ["always", "never", "ignore"]
                            },
                            asyncArrow: {
                                enum: ["always", "never", "ignore"]
                            }
                        },
                        additionalProperties: false
                    }
                ]
            }
        ]
    },

    create(context) {
<<<<<<< HEAD

        const configuration = context.options[0],
            sourceCode = context.getSourceCode();
        let requireAnonymousFunctionSpacing = true,
            forbidAnonymousFunctionSpacing = false,
            requireNamedFunctionSpacing = true,
            forbidNamedFunctionSpacing = false,
            requireArrowFunctionSpacing = false,
            forbidArrowFunctionSpacing = false;

        if (typeof configuration === "object") {
            requireAnonymousFunctionSpacing = (
                !configuration.anonymous || configuration.anonymous === "always");
            forbidAnonymousFunctionSpacing = configuration.anonymous === "never";
            requireNamedFunctionSpacing = (
                !configuration.named || configuration.named === "always");
            forbidNamedFunctionSpacing = configuration.named === "never";
            requireArrowFunctionSpacing = configuration.asyncArrow === "always";
            forbidArrowFunctionSpacing = configuration.asyncArrow === "never";
        } else if (configuration === "never") {
            requireAnonymousFunctionSpacing = false;
            forbidAnonymousFunctionSpacing = true;
            requireNamedFunctionSpacing = false;
            forbidNamedFunctionSpacing = true;
        }
=======
        const sourceCode = context.getSourceCode();
        const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
        const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2

        /**
         * Determines whether a function has a name.
         * @param {ASTNode} node The function node.
         * @returns {boolean} Whether the function has a name.
         */
        function isNamedFunction(node) {
            if (node.id) {
                return true;
            }

            const parent = node.parent;

            return parent.type === "MethodDefinition" ||
                (parent.type === "Property" &&
                    (
                        parent.kind === "get" ||
                        parent.kind === "set" ||
                        parent.method
                    )
                );
        }

        /**
<<<<<<< HEAD
         * Validates the spacing before function parentheses.
         * @param {ASTNode} node The node to be validated.
         * @returns {void}
         */
        function validateSpacingBeforeParentheses(node) {
            const isArrow = node.type === "ArrowFunctionExpression";
            const isNamed = !isArrow && isNamedFunction(node);
            const isAnonymousGenerator = node.generator && !isNamed;
            const isNormalArrow = isArrow && !node.async;
            const isArrowWithoutParens = isArrow && sourceCode.getFirstToken(node, 1).value !== "(";
            let forbidSpacing, requireSpacing;

            // isAnonymousGenerator → `generator-star-spacing` should warn it. E.g. `function* () {}`
            // isNormalArrow → ignore always.
            // isArrowWithoutParens → ignore always. E.g. `async a => a`
            if (isAnonymousGenerator || isNormalArrow || isArrowWithoutParens) {
                return;
            }

            if (isArrow) {
                forbidSpacing = forbidArrowFunctionSpacing;
                requireSpacing = requireArrowFunctionSpacing;
            } else if (isNamed) {
                forbidSpacing = forbidNamedFunctionSpacing;
                requireSpacing = requireNamedFunctionSpacing;
            } else {
                forbidSpacing = forbidAnonymousFunctionSpacing;
                requireSpacing = requireAnonymousFunctionSpacing;
=======
         * Gets the config for a given function
         * @param {ASTNode} node The function node
         * @returns {string} "always", "never", or "ignore"
         */
        function getConfigForFunction(node) {
            if (node.type === "ArrowFunctionExpression") {

                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar
                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
                    return overrideConfig.asyncArrow || baseConfig;
                }
            } else if (isNamedFunction(node)) {
                return overrideConfig.named || baseConfig;

            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`
            } else if (!node.generator) {
                return overrideConfig.anonymous || baseConfig;
            }

            return "ignore";
        }

        /**
         * Checks the parens of a function node
         * @param {ASTNode} node A function node
         * @returns {void}
         */
        function checkFunction(node) {
            const functionConfig = getConfigForFunction(node);

            if (functionConfig === "ignore") {
                return;
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
            }

            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            const leftToken = sourceCode.getTokenBefore(rightToken);
<<<<<<< HEAD
            const location = leftToken.loc.end;

            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
                if (forbidSpacing) {
                    context.report({
                        node,
                        loc: location,
                        message: "Unexpected space before function parentheses.",
                        fix(fixer) {
                            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                        }
                    });
                }
            } else {
                if (requireSpacing) {
                    context.report({
                        node,
                        loc: location,
                        message: "Missing space before function parentheses.",
                        fix(fixer) {
                            return fixer.insertTextAfter(leftToken, " ");
                        }
                    });
                }
=======
            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);

            if (hasSpacing && functionConfig === "never") {
                context.report({
                    node,
                    loc: leftToken.loc.end,
                    message: "Unexpected space before function parentheses.",
                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])
                });
            } else if (!hasSpacing && functionConfig === "always") {
                context.report({
                    node,
                    loc: leftToken.loc.end,
                    message: "Missing space before function parentheses.",
                    fix: fixer => fixer.insertTextAfter(leftToken, " ")
                });
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
            }
        }

        return {
<<<<<<< HEAD
            FunctionDeclaration: validateSpacingBeforeParentheses,
            FunctionExpression: validateSpacingBeforeParentheses,
            ArrowFunctionExpression: validateSpacingBeforeParentheses
=======
            ArrowFunctionExpression: checkFunction,
            FunctionDeclaration: checkFunction,
            FunctionExpression: checkFunction
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
        };
    }
};
