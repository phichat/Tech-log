<<<<<<< HEAD
(function() {
  var AtRule, Browsers, Declaration, Prefixes, Processor, Resolution, Selector, Supports, Transition, Value, declsCache, utils, vendor;

  Declaration = require('./declaration');

  Resolution = require('./resolution');

  Transition = require('./transition');

  Processor = require('./processor');

  Supports = require('./supports');

  Browsers = require('./browsers');

  Selector = require('./selector');

  AtRule = require('./at-rule');

  Value = require('./value');

  utils = require('./utils');

  vendor = require('postcss/lib/vendor');

  Selector.hack(require('./hacks/fullscreen'));

  Selector.hack(require('./hacks/placeholder'));

  Declaration.hack(require('./hacks/flex'));

  Declaration.hack(require('./hacks/order'));

  Declaration.hack(require('./hacks/filter'));

  Declaration.hack(require('./hacks/grid-end'));

  Declaration.hack(require('./hacks/flex-flow'));

  Declaration.hack(require('./hacks/flex-grow'));

  Declaration.hack(require('./hacks/flex-wrap'));

  Declaration.hack(require('./hacks/grid-start'));

  Declaration.hack(require('./hacks/align-self'));

  Declaration.hack(require('./hacks/flex-basis'));

  Declaration.hack(require('./hacks/mask-border'));

  Declaration.hack(require('./hacks/align-items'));

  Declaration.hack(require('./hacks/flex-shrink'));

  Declaration.hack(require('./hacks/break-props'));

  Declaration.hack(require('./hacks/writing-mode'));

  Declaration.hack(require('./hacks/border-image'));

  Declaration.hack(require('./hacks/justify-items'));

  Declaration.hack(require('./hacks/align-content'));

  Declaration.hack(require('./hacks/border-radius'));

  Declaration.hack(require('./hacks/block-logical'));

  Declaration.hack(require('./hacks/grid-template'));

  Declaration.hack(require('./hacks/inline-logical'));

  Declaration.hack(require('./hacks/grid-row-align'));

  Declaration.hack(require('./hacks/transform-decl'));

  Declaration.hack(require('./hacks/flex-direction'));

  Declaration.hack(require('./hacks/image-rendering'));

  Declaration.hack(require('./hacks/justify-content'));

  Declaration.hack(require('./hacks/background-size'));

  Declaration.hack(require('./hacks/text-emphasis-position'));

  Value.hack(require('./hacks/stretch'));

  Value.hack(require('./hacks/gradient'));

  Value.hack(require('./hacks/pixelated'));

  Value.hack(require('./hacks/image-set'));

  Value.hack(require('./hacks/cross-fade'));

  Value.hack(require('./hacks/flex-values'));

  Value.hack(require('./hacks/display-flex'));

  Value.hack(require('./hacks/display-grid'));

  Value.hack(require('./hacks/filter-value'));

  declsCache = {};

  Prefixes = (function() {
    function Prefixes(data1, browsers, options) {
      var ref;
      this.data = data1;
      this.browsers = browsers;
      this.options = options != null ? options : {};
      ref = this.preprocess(this.select(this.data)), this.add = ref[0], this.remove = ref[1];
      this.transition = new Transition(this);
      this.processor = new Processor(this);
    }

    Prefixes.prototype.cleaner = function() {
      var empty;
      if (!this.cleanerCache) {
        if (this.browsers.selected.length) {
          empty = new Browsers(this.browsers.data, []);
          this.cleanerCache = new Prefixes(this.data, empty, this.options);
        } else {
          return this;
        }
      }
      return this.cleanerCache;
    };

    Prefixes.prototype.select = function(list) {
      var add, all, data, name, notes, selected;
      selected = {
        add: {},
        remove: {}
      };
      for (name in list) {
        data = list[name];
        add = data.browsers.map(function(i) {
          var params;
          params = i.split(' ');
          return {
            browser: params[0] + ' ' + params[1],
            note: params[2]
          };
        });
        notes = add.filter(function(i) {
          return i.note;
        }).map((function(_this) {
          return function(i) {
            return _this.browsers.prefix(i.browser) + ' ' + i.note;
          };
        })(this));
        notes = utils.uniq(notes);
        add = add.filter((function(_this) {
          return function(i) {
            return _this.browsers.isSelected(i.browser);
          };
        })(this)).map((function(_this) {
          return function(i) {
            var prefix;
            prefix = _this.browsers.prefix(i.browser);
            if (i.note) {
              return prefix + ' ' + i.note;
            } else {
              return prefix;
            }
          };
        })(this));
        add = this.sort(utils.uniq(add));
        if (this.options.flexbox === 'no-2009') {
          add = add.filter(function(i) {
            return i.indexOf('2009') === -1;
          });
        }
        all = data.browsers.map((function(_this) {
          return function(i) {
            return _this.browsers.prefix(i);
          };
        })(this));
        if (data.mistakes) {
          all = all.concat(data.mistakes);
        }
        all = all.concat(notes);
        all = utils.uniq(all);
        if (add.length) {
          selected.add[name] = add;
          if (add.length < all.length) {
            selected.remove[name] = all.filter(function(i) {
              return add.indexOf(i) === -1;
            });
          }
        } else {
          selected.remove[name] = all;
        }
      }
      return selected;
    };

    Prefixes.prototype.sort = function(prefixes) {
      return prefixes.sort(function(a, b) {
        var aLength, bLength;
        aLength = utils.removeNote(a).length;
        bLength = utils.removeNote(b).length;
        if (aLength === bLength) {
          return b.length - a.length;
        } else {
          return bLength - aLength;
        }
      });
    };

    Prefixes.prototype.preprocess = function(selected) {
      var a, add, j, k, l, len, len1, len2, len3, len4, len5, len6, m, n, name, o, old, olds, p, prefix, prefixed, prefixes, prop, props, ref, ref1, ref2, ref3, remove, selector, value, values;
      add = {
        selectors: [],
        '@supports': new Supports(Prefixes, this)
      };
      ref = selected.add;
      for (name in ref) {
        prefixes = ref[name];
        if (name === '@keyframes' || name === '@viewport') {
          add[name] = new AtRule(name, prefixes, this);
        } else if (name === '@resolution') {
          add[name] = new Resolution(name, prefixes, this);
        } else if (this.data[name].selector) {
          add.selectors.push(Selector.load(name, prefixes, this));
        } else {
          props = this.data[name].props;
          if (props) {
            value = Value.load(name, prefixes, this);
            for (j = 0, len = props.length; j < len; j++) {
              prop = props[j];
              if (!add[prop]) {
                add[prop] = {
                  values: []
                };
              }
              add[prop].values.push(value);
            }
          } else {
            values = ((ref1 = add[name]) != null ? ref1.values : void 0) || [];
            add[name] = Declaration.load(name, prefixes, this);
            add[name].values = values;
          }
        }
      }
      remove = {
        selectors: []
      };
      ref2 = selected.remove;
      for (name in ref2) {
        prefixes = ref2[name];
        if (this.data[name].selector) {
          selector = Selector.load(name, prefixes);
          for (k = 0, len1 = prefixes.length; k < len1; k++) {
            prefix = prefixes[k];
            remove.selectors.push(selector.old(prefix));
          }
        } else if (name === '@keyframes' || name === '@viewport') {
          for (l = 0, len2 = prefixes.length; l < len2; l++) {
            prefix = prefixes[l];
            prefixed = '@' + prefix + name.slice(1);
            remove[prefixed] = {
              remove: true
            };
          }
        } else if (name === '@resolution') {
          remove[name] = new Resolution(name, prefixes, this);
        } else {
          props = this.data[name].props;
          if (props) {
            value = Value.load(name, [], this);
            for (m = 0, len3 = prefixes.length; m < len3; m++) {
              prefix = prefixes[m];
              old = value.old(prefix);
              if (old) {
                for (n = 0, len4 = props.length; n < len4; n++) {
                  prop = props[n];
                  if (!remove[prop]) {
                    remove[prop] = {};
                  }
                  if (!remove[prop].values) {
                    remove[prop].values = [];
                  }
                  remove[prop].values.push(old);
                }
              }
            }
          } else {
            for (o = 0, len5 = prefixes.length; o < len5; o++) {
              prefix = prefixes[o];
              prop = vendor.unprefixed(name);
              olds = this.decl(name).old(name, prefix);
              if (name === 'align-self') {
                a = (ref3 = add[name]) != null ? ref3.prefixes : void 0;
                if (a) {
                  if (prefix === '-webkit- 2009' && a.indexOf('-webkit-') !== -1) {
                    continue;
                  } else if (prefix === '-webkit-' && a.indexOf('-webkit- 2009') !== -1) {
                    continue;
                  }
                }
              }
              for (p = 0, len6 = olds.length; p < len6; p++) {
                prefixed = olds[p];
                if (!remove[prefixed]) {
                  remove[prefixed] = {};
                }
                remove[prefixed].remove = true;
              }
            }
          }
        }
      }
      return [add, remove];
    };

    Prefixes.prototype.decl = function(prop) {
      var decl;
      decl = declsCache[prop];
      if (decl) {
        return decl;
      } else {
        return declsCache[prop] = Declaration.load(prop);
      }
    };

    Prefixes.prototype.unprefixed = function(prop) {
      var value;
      value = this.normalize(vendor.unprefixed(prop));
      if (value === 'flex-direction') {
        value = 'flex-flow';
      }
      return value;
    };

    Prefixes.prototype.normalize = function(prop) {
      return this.decl(prop).normalize(prop);
    };

    Prefixes.prototype.prefixed = function(prop, prefix) {
      prop = vendor.unprefixed(prop);
      return this.decl(prop).prefixed(prop, prefix);
    };

    Prefixes.prototype.values = function(type, prop) {
      var data, global, ref, ref1, values;
      data = this[type];
      global = (ref = data['*']) != null ? ref.values : void 0;
      values = (ref1 = data[prop]) != null ? ref1.values : void 0;
      if (global && values) {
        return utils.uniq(global.concat(values));
      } else {
        return global || values || [];
      }
    };

    Prefixes.prototype.group = function(decl) {
      var checker, index, length, rule, unprefixed;
      rule = decl.parent;
      index = rule.index(decl);
      length = rule.nodes.length;
      unprefixed = this.unprefixed(decl.prop);
      checker = (function(_this) {
        return function(step, callback) {
          var other;
          index += step;
          while (index >= 0 && index < length) {
            other = rule.nodes[index];
            if (other.type === 'decl') {
              if (step === -1 && other.prop === unprefixed) {
                if (!Browsers.withPrefix(other.value)) {
                  break;
                }
              }
              if (_this.unprefixed(other.prop) !== unprefixed) {
                break;
              } else if (callback(other) === true) {
                return true;
              }
              if (step === +1 && other.prop === unprefixed) {
                if (!Browsers.withPrefix(other.value)) {
                  break;
                }
              }
            }
            index += step;
          }
          return false;
        };
      })(this);
      return {
        up: function(callback) {
          return checker(-1, callback);
        },
        down: function(callback) {
          return checker(+1, callback);
        }
      };
    };

    return Prefixes;

  })();

  module.exports = Prefixes;

}).call(this);
=======
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Declaration = require('./declaration');
var Resolution = require('./resolution');
var Transition = require('./transition');
var Processor = require('./processor');
var Supports = require('./supports');
var Browsers = require('./browsers');
var Selector = require('./selector');
var AtRule = require('./at-rule');
var Value = require('./value');
var utils = require('./utils');

var vendor = require('postcss/lib/vendor');

Selector.hack(require('./hacks/fullscreen'));
Selector.hack(require('./hacks/placeholder'));

Declaration.hack(require('./hacks/flex'));
Declaration.hack(require('./hacks/order'));
Declaration.hack(require('./hacks/filter'));
Declaration.hack(require('./hacks/grid-end'));
Declaration.hack(require('./hacks/animation'));
Declaration.hack(require('./hacks/flex-flow'));
Declaration.hack(require('./hacks/flex-grow'));
Declaration.hack(require('./hacks/flex-wrap'));
Declaration.hack(require('./hacks/grid-area'));
Declaration.hack(require('./hacks/grid-start'));
Declaration.hack(require('./hacks/align-self'));
Declaration.hack(require('./hacks/appearance'));
Declaration.hack(require('./hacks/flex-basis'));
Declaration.hack(require('./hacks/mask-border'));
Declaration.hack(require('./hacks/align-items'));
Declaration.hack(require('./hacks/flex-shrink'));
Declaration.hack(require('./hacks/break-props'));
Declaration.hack(require('./hacks/writing-mode'));
Declaration.hack(require('./hacks/border-image'));
Declaration.hack(require('./hacks/align-content'));
Declaration.hack(require('./hacks/border-radius'));
Declaration.hack(require('./hacks/block-logical'));
Declaration.hack(require('./hacks/grid-template'));
Declaration.hack(require('./hacks/inline-logical'));
Declaration.hack(require('./hacks/grid-row-align'));
Declaration.hack(require('./hacks/transform-decl'));
Declaration.hack(require('./hacks/flex-direction'));
Declaration.hack(require('./hacks/image-rendering'));
Declaration.hack(require('./hacks/text-decoration'));
Declaration.hack(require('./hacks/justify-content'));
Declaration.hack(require('./hacks/background-size'));
Declaration.hack(require('./hacks/grid-row-column'));
Declaration.hack(require('./hacks/grid-rows-columns'));
Declaration.hack(require('./hacks/grid-column-align'));
Declaration.hack(require('./hacks/grid-template-areas'));
Declaration.hack(require('./hacks/text-emphasis-position'));

Value.hack(require('./hacks/gradient'));
Value.hack(require('./hacks/intrinsic'));
Value.hack(require('./hacks/pixelated'));
Value.hack(require('./hacks/image-set'));
Value.hack(require('./hacks/cross-fade'));
Value.hack(require('./hacks/display-flex'));
Value.hack(require('./hacks/display-grid'));
Value.hack(require('./hacks/filter-value'));

var declsCache = {};

var Prefixes = function () {
    function Prefixes(data, browsers) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, Prefixes);

        this.data = data;
        this.browsers = browsers;
        this.options = options;

        var _preprocess = this.preprocess(this.select(this.data));

        this.add = _preprocess[0];
        this.remove = _preprocess[1];

        this.transition = new Transition(this);
        this.processor = new Processor(this);
    }

    /**
     * Return clone instance to remove all prefixes
     */


    Prefixes.prototype.cleaner = function cleaner() {
        if (this.cleanerCache) {
            return this.cleanerCache;
        }

        if (this.browsers.selected.length) {
            var empty = new Browsers(this.browsers.data, []);
            this.cleanerCache = new Prefixes(this.data, empty, this.options);
        } else {
            return this;
        }

        return this.cleanerCache;
    };

    /**
     * Select prefixes from data, which is necessary for selected browsers
     */


    Prefixes.prototype.select = function select(list) {
        var _this = this;

        var selected = { add: {}, remove: {} };

        var _loop = function _loop(name) {
            var data = list[name];
            var add = data.browsers.map(function (i) {
                var params = i.split(' ');
                return {
                    browser: params[0] + ' ' + params[1],
                    note: params[2]
                };
            });

            var notes = add.filter(function (i) {
                return i.note;
            }).map(function (i) {
                return _this.browsers.prefix(i.browser) + ' ' + i.note;
            });
            notes = utils.uniq(notes);

            add = add.filter(function (i) {
                return _this.browsers.isSelected(i.browser);
            }).map(function (i) {
                var prefix = _this.browsers.prefix(i.browser);
                if (i.note) {
                    return prefix + ' ' + i.note;
                } else {
                    return prefix;
                }
            });
            add = _this.sort(utils.uniq(add));

            if (_this.options.flexbox === 'no-2009') {
                add = add.filter(function (i) {
                    return i.indexOf('2009') === -1;
                });
            }

            var all = data.browsers.map(function (i) {
                return _this.browsers.prefix(i);
            });
            if (data.mistakes) {
                all = all.concat(data.mistakes);
            }
            all = all.concat(notes);
            all = utils.uniq(all);

            if (add.length) {
                selected.add[name] = add;
                if (add.length < all.length) {
                    selected.remove[name] = all.filter(function (i) {
                        return add.indexOf(i) === -1;
                    });
                }
            } else {
                selected.remove[name] = all;
            }
        };

        for (var name in list) {
            _loop(name);
        }

        return selected;
    };

    /**
     * Sort vendor prefixes
     */


    Prefixes.prototype.sort = function sort(prefixes) {
        return prefixes.sort(function (a, b) {
            var aLength = utils.removeNote(a).length;
            var bLength = utils.removeNote(b).length;

            if (aLength === bLength) {
                return b.length - a.length;
            } else {
                return bLength - aLength;
            }
        });
    };

    /**
     * Cache prefixes data to fast CSS processing
     */


    Prefixes.prototype.preprocess = function preprocess(selected) {
        var add = {
            'selectors': [],
            '@supports': new Supports(Prefixes, this)
        };
        for (var name in selected.add) {
            var prefixes = selected.add[name];
            if (name === '@keyframes' || name === '@viewport') {
                add[name] = new AtRule(name, prefixes, this);
            } else if (name === '@resolution') {
                add[name] = new Resolution(name, prefixes, this);
            } else if (this.data[name].selector) {
                add.selectors.push(Selector.load(name, prefixes, this));
            } else {
                var props = this.data[name].props;

                if (props) {
                    var value = Value.load(name, prefixes, this);
                    for (var _iterator = props, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                        var _ref;

                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done) break;
                            _ref = _i.value;
                        }

                        var prop = _ref;

                        if (!add[prop]) {
                            add[prop] = { values: [] };
                        }
                        add[prop].values.push(value);
                    }
                } else {
                    var values = add[name] && add[name].values || [];
                    add[name] = Declaration.load(name, prefixes, this);
                    add[name].values = values;
                }
            }
        }

        var remove = { selectors: [] };
        for (var _name in selected.remove) {
            var _prefixes = selected.remove[_name];
            if (this.data[_name].selector) {
                var selector = Selector.load(_name, _prefixes);
                for (var _iterator2 = _prefixes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var prefix = _ref2;

                    remove.selectors.push(selector.old(prefix));
                }
            } else if (_name === '@keyframes' || _name === '@viewport') {
                for (var _iterator3 = _prefixes, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                    var _ref3;

                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done) break;
                        _ref3 = _i3.value;
                    }

                    var _prefix = _ref3;

                    var prefixed = '@' + _prefix + _name.slice(1);
                    remove[prefixed] = { remove: true };
                }
            } else if (_name === '@resolution') {
                remove[_name] = new Resolution(_name, _prefixes, this);
            } else {
                var _props = this.data[_name].props;
                if (_props) {
                    var _value = Value.load(_name, [], this);
                    for (var _iterator4 = _prefixes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                        var _ref4;

                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done) break;
                            _ref4 = _i4.value;
                        }

                        var _prefix2 = _ref4;

                        var old = _value.old(_prefix2);
                        if (old) {
                            for (var _iterator5 = _props, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                                var _ref5;

                                if (_isArray5) {
                                    if (_i5 >= _iterator5.length) break;
                                    _ref5 = _iterator5[_i5++];
                                } else {
                                    _i5 = _iterator5.next();
                                    if (_i5.done) break;
                                    _ref5 = _i5.value;
                                }

                                var _prop = _ref5;

                                if (!remove[_prop]) {
                                    remove[_prop] = {};
                                }
                                if (!remove[_prop].values) {
                                    remove[_prop].values = [];
                                }
                                remove[_prop].values.push(old);
                            }
                        }
                    }
                } else {
                    for (var _iterator6 = _prefixes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                        var _ref6;

                        if (_isArray6) {
                            if (_i6 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i6++];
                        } else {
                            _i6 = _iterator6.next();
                            if (_i6.done) break;
                            _ref6 = _i6.value;
                        }

                        var _prefix3 = _ref6;

                        var olds = this.decl(_name).old(_name, _prefix3);
                        if (_name === 'align-self') {
                            var a = add[_name] && add[_name].prefixes;
                            if (a) {
                                if (_prefix3 === '-webkit- 2009' && a.indexOf('-webkit-') !== -1) {
                                    continue;
                                } else if (_prefix3 === '-webkit-' && a.indexOf('-webkit- 2009') !== -1) {
                                    continue;
                                }
                            }
                        }
                        for (var _iterator7 = olds, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
                            var _ref7;

                            if (_isArray7) {
                                if (_i7 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i7++];
                            } else {
                                _i7 = _iterator7.next();
                                if (_i7.done) break;
                                _ref7 = _i7.value;
                            }

                            var _prefixed = _ref7;

                            if (!remove[_prefixed]) {
                                remove[_prefixed] = {};
                            }
                            remove[_prefixed].remove = true;
                        }
                    }
                }
            }
        }

        return [add, remove];
    };

    /**
     * Declaration loader with caching
     */


    Prefixes.prototype.decl = function decl(prop) {
        var decl = declsCache[prop];

        if (decl) {
            return decl;
        } else {
            declsCache[prop] = Declaration.load(prop);
            return declsCache[prop];
        }
    };

    /**
     * Return unprefixed version of property
     */


    Prefixes.prototype.unprefixed = function unprefixed(prop) {
        var value = this.normalize(vendor.unprefixed(prop));
        if (value === 'flex-direction') {
            value = 'flex-flow';
        }
        return value;
    };

    /**
     * Normalize prefix for remover
     */


    Prefixes.prototype.normalize = function normalize(prop) {
        return this.decl(prop).normalize(prop);
    };

    /**
     * Return prefixed version of property
     */


    Prefixes.prototype.prefixed = function prefixed(prop, prefix) {
        prop = vendor.unprefixed(prop);
        return this.decl(prop).prefixed(prop, prefix);
    };

    /**
     * Return values, which must be prefixed in selected property
     */


    Prefixes.prototype.values = function values(type, prop) {
        var data = this[type];

        var global = data['*'] && data['*'].values;
        var values = data[prop] && data[prop].values;

        if (global && values) {
            return utils.uniq(global.concat(values));
        } else {
            return global || values || [];
        }
    };

    /**
     * Group declaration by unprefixed property to check them
     */


    Prefixes.prototype.group = function group(decl) {
        var _this2 = this;

        var rule = decl.parent;
        var index = rule.index(decl);
        var length = rule.nodes.length;

        var unprefixed = this.unprefixed(decl.prop);

        var checker = function checker(step, callback) {
            index += step;
            while (index >= 0 && index < length) {
                var other = rule.nodes[index];
                if (other.type === 'decl') {

                    if (step === -1 && other.prop === unprefixed) {
                        if (!Browsers.withPrefix(other.value)) {
                            break;
                        }
                    }

                    if (_this2.unprefixed(other.prop) !== unprefixed) {
                        break;
                    } else if (callback(other) === true) {
                        return true;
                    }

                    if (step === +1 && other.prop === unprefixed) {
                        if (!Browsers.withPrefix(other.value)) {
                            break;
                        }
                    }
                }

                index += step;
            }
            return false;
        };

        return {
            up: function up(callback) {
                return checker(-1, callback);
            },
            down: function down(callback) {
                return checker(+1, callback);
            }
        };
    };

    return Prefixes;
}();

module.exports = Prefixes;
>>>>>>> 09665636ba9818fc952cd8bfe693d791912356d2
